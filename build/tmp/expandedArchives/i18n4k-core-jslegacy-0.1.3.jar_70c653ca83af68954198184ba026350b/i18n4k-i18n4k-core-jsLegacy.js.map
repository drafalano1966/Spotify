{"version":3,"file":"i18n4k-i18n4k-core-jsLegacy.js","sources":["collections/Collections.kt","text/Strings.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/strings/LocalizedNumberString.kt","kotlin/math.kt","kotlin/text/char.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/LocaleUtils.kt","kotlin/text/string.kt","util/Standard.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/config/I18n4kConfigDefault.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/config/I18n4kConfigDelegate.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/config/I18n4kConfigImmutable.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/messages/MessageBundle.kt","../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/messages/formatter/MessageFormatter.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/messages/formatter/MessageFormatterDefault.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/messages/formatter/MessageNumberFormatter.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/messages/providers/MessagesProviderViaList.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/messages/providers/MessagesProviderViaLoading.kt","util/Lazy.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/messages/providers/MessagesProviderViaLoadingText.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/messages/providers/MessagesProviderViaText.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/strings/AbstractLocalizedString.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/strings/EmptyLocalizedString.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/strings/LocalizedString.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/strings/LocalizedStringFactories.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/strings/ParameterisedLocalizedString.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/strings/SimpleLocalizedString.kt","../../../../../i18n4k-core/src/jsMain/kotlin/de/comahe/i18n4k/Locale.kt","../../../../../i18n4k-core/src/jsMain/kotlin/de/comahe/i18n4k/messages/provider/MessagesProviderFactoryViaFetch.kt","org.w3c/org.w3c.fetch.kt","kotlin/promise.kt","../../../../../i18n4k-core/src/commonMain/kotlin/de/comahe/i18n4k/I18n4k.kt"],"sourcesContent":["/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n",null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n// actually \\s is enough to match all whitespace, but \\xA0 added because of different regexp behavior of Rhino used in Selenium tests\npublic actual fun Char.isWhitespace(): Boolean = toString().matches(\"[\\\\s\\\\xA0]\")\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@OptIn(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = toString().asDynamic().toLowerCase().charCodeAt(0).unsafeCast<Int>().toChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`\u0130`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase() as String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@OptIn(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`\ufb00`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase() as String\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n",null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n",null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.w3c.fetch\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.encryptedmedia.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.mediasource.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\n/**\n * Exposes the JavaScript [Headers](https://developer.mozilla.org/en/docs/Web/API/Headers) to Kotlin\n */\npublic external open class Headers(init: dynamic = definedExternally) {\n    fun append(name: String, value: String)\n    fun delete(name: String)\n    fun get(name: String): String?\n    fun has(name: String): Boolean\n    fun set(name: String, value: String)\n}\n\n/**\n * Exposes the JavaScript [Body](https://developer.mozilla.org/en/docs/Web/API/Body) to Kotlin\n */\npublic external interface Body {\n    val bodyUsed: Boolean\n    fun arrayBuffer(): Promise<ArrayBuffer>\n    fun blob(): Promise<Blob>\n    fun formData(): Promise<FormData>\n    fun json(): Promise<Any?>\n    fun text(): Promise<String>\n}\n\n/**\n * Exposes the JavaScript [Request](https://developer.mozilla.org/en/docs/Web/API/Request) to Kotlin\n */\npublic external open class Request(input: dynamic, init: RequestInit = definedExternally) : Body {\n    open val method: String\n    open val url: String\n    open val headers: Headers\n    open val type: RequestType\n    open val destination: RequestDestination\n    open val referrer: String\n    open val referrerPolicy: dynamic\n    open val mode: RequestMode\n    open val credentials: RequestCredentials\n    open val cache: RequestCache\n    open val redirect: RequestRedirect\n    open val integrity: String\n    open val keepalive: Boolean\n    override val bodyUsed: Boolean\n    fun clone(): Request\n    override fun arrayBuffer(): Promise<ArrayBuffer>\n    override fun blob(): Promise<Blob>\n    override fun formData(): Promise<FormData>\n    override fun json(): Promise<Any?>\n    override fun text(): Promise<String>\n}\n\npublic external interface RequestInit {\n    var method: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var headers: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var body: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var referrer: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var referrerPolicy: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var mode: RequestMode?\n        get() = definedExternally\n        set(value) = definedExternally\n    var credentials: RequestCredentials?\n        get() = definedExternally\n        set(value) = definedExternally\n    var cache: RequestCache?\n        get() = definedExternally\n        set(value) = definedExternally\n    var redirect: RequestRedirect?\n        get() = definedExternally\n        set(value) = definedExternally\n    var integrity: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var keepalive: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var window: Any?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun RequestInit(method: String? = undefined, headers: dynamic = undefined, body: dynamic = undefined, referrer: String? = undefined, referrerPolicy: dynamic = undefined, mode: RequestMode? = undefined, credentials: RequestCredentials? = undefined, cache: RequestCache? = undefined, redirect: RequestRedirect? = undefined, integrity: String? = undefined, keepalive: Boolean? = undefined, window: Any? = undefined): RequestInit {\n    val o = js(\"({})\")\n    o[\"method\"] = method\n    o[\"headers\"] = headers\n    o[\"body\"] = body\n    o[\"referrer\"] = referrer\n    o[\"referrerPolicy\"] = referrerPolicy\n    o[\"mode\"] = mode\n    o[\"credentials\"] = credentials\n    o[\"cache\"] = cache\n    o[\"redirect\"] = redirect\n    o[\"integrity\"] = integrity\n    o[\"keepalive\"] = keepalive\n    o[\"window\"] = window\n    return o\n}\n\n/**\n * Exposes the JavaScript [Response](https://developer.mozilla.org/en/docs/Web/API/Response) to Kotlin\n */\npublic external open class Response(body: dynamic = definedExternally, init: ResponseInit = definedExternally) : Body {\n    open val type: ResponseType\n    open val url: String\n    open val redirected: Boolean\n    open val status: Short\n    open val ok: Boolean\n    open val statusText: String\n    open val headers: Headers\n    open val body: dynamic\n    open val trailer: Promise<Headers>\n    override val bodyUsed: Boolean\n    fun clone(): Response\n    override fun arrayBuffer(): Promise<ArrayBuffer>\n    override fun blob(): Promise<Blob>\n    override fun formData(): Promise<FormData>\n    override fun json(): Promise<Any?>\n    override fun text(): Promise<String>\n\n    companion object {\n        fun error(): Response\n        fun redirect(url: String, status: Short = definedExternally): Response\n    }\n}\n\npublic external interface ResponseInit {\n    var status: Short? /* = 200 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var statusText: String? /* = \"OK\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var headers: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ResponseInit(status: Short? = 200, statusText: String? = \"OK\", headers: dynamic = undefined): ResponseInit {\n    val o = js(\"({})\")\n    o[\"status\"] = status\n    o[\"statusText\"] = statusText\n    o[\"headers\"] = headers\n    return o\n}\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestType {\n    companion object\n}\n\npublic inline val RequestType.Companion.EMPTY: RequestType get() = \"\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.AUDIO: RequestType get() = \"audio\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.FONT: RequestType get() = \"font\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.IMAGE: RequestType get() = \"image\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.SCRIPT: RequestType get() = \"script\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.STYLE: RequestType get() = \"style\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.TRACK: RequestType get() = \"track\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.VIDEO: RequestType get() = \"video\".asDynamic().unsafeCast<RequestType>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestDestination {\n    companion object\n}\n\npublic inline val RequestDestination.Companion.EMPTY: RequestDestination get() = \"\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.DOCUMENT: RequestDestination get() = \"document\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.EMBED: RequestDestination get() = \"embed\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.FONT: RequestDestination get() = \"font\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.IMAGE: RequestDestination get() = \"image\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.MANIFEST: RequestDestination get() = \"manifest\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.MEDIA: RequestDestination get() = \"media\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.OBJECT: RequestDestination get() = \"object\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.REPORT: RequestDestination get() = \"report\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.SCRIPT: RequestDestination get() = \"script\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.SERVICEWORKER: RequestDestination get() = \"serviceworker\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.SHAREDWORKER: RequestDestination get() = \"sharedworker\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.STYLE: RequestDestination get() = \"style\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.WORKER: RequestDestination get() = \"worker\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.XSLT: RequestDestination get() = \"xslt\".asDynamic().unsafeCast<RequestDestination>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestMode {\n    companion object\n}\n\npublic inline val RequestMode.Companion.NAVIGATE: RequestMode get() = \"navigate\".asDynamic().unsafeCast<RequestMode>()\n\npublic inline val RequestMode.Companion.SAME_ORIGIN: RequestMode get() = \"same-origin\".asDynamic().unsafeCast<RequestMode>()\n\npublic inline val RequestMode.Companion.NO_CORS: RequestMode get() = \"no-cors\".asDynamic().unsafeCast<RequestMode>()\n\npublic inline val RequestMode.Companion.CORS: RequestMode get() = \"cors\".asDynamic().unsafeCast<RequestMode>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestCredentials {\n    companion object\n}\n\npublic inline val RequestCredentials.Companion.OMIT: RequestCredentials get() = \"omit\".asDynamic().unsafeCast<RequestCredentials>()\n\npublic inline val RequestCredentials.Companion.SAME_ORIGIN: RequestCredentials get() = \"same-origin\".asDynamic().unsafeCast<RequestCredentials>()\n\npublic inline val RequestCredentials.Companion.INCLUDE: RequestCredentials get() = \"include\".asDynamic().unsafeCast<RequestCredentials>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestCache {\n    companion object\n}\n\npublic inline val RequestCache.Companion.DEFAULT: RequestCache get() = \"default\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.NO_STORE: RequestCache get() = \"no-store\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.RELOAD: RequestCache get() = \"reload\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.NO_CACHE: RequestCache get() = \"no-cache\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.FORCE_CACHE: RequestCache get() = \"force-cache\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.ONLY_IF_CACHED: RequestCache get() = \"only-if-cached\".asDynamic().unsafeCast<RequestCache>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestRedirect {\n    companion object\n}\n\npublic inline val RequestRedirect.Companion.FOLLOW: RequestRedirect get() = \"follow\".asDynamic().unsafeCast<RequestRedirect>()\n\npublic inline val RequestRedirect.Companion.ERROR: RequestRedirect get() = \"error\".asDynamic().unsafeCast<RequestRedirect>()\n\npublic inline val RequestRedirect.Companion.MANUAL: RequestRedirect get() = \"manual\".asDynamic().unsafeCast<RequestRedirect>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ResponseType {\n    companion object\n}\n\npublic inline val ResponseType.Companion.BASIC: ResponseType get() = \"basic\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.CORS: ResponseType get() = \"cors\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.DEFAULT: ResponseType get() = \"default\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.ERROR: ResponseType get() = \"error\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.OPAQUE: ResponseType get() = \"opaque\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.OPAQUEREDIRECT: ResponseType get() = \"opaqueredirect\".asDynamic().unsafeCast<ResponseType>()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\nimport kotlin.internal.LowPriorityInOverloadResolution\n\n/**\n * Exposes the JavaScript [Promise object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic open external class Promise<out T>(executor: (resolve: (T) -> Unit, reject: (Throwable) -> Unit) -> Unit) {\n    @LowPriorityInOverloadResolution\n    public open fun <S> then(onFulfilled: ((T) -> S)?): Promise<S>\n\n    @LowPriorityInOverloadResolution\n    public open fun <S> then(onFulfilled: ((T) -> S)?, onRejected: ((Throwable) -> S)?): Promise<S>\n\n    public open fun <S> catch(onRejected: (Throwable) -> S): Promise<S>\n\n    companion object {\n        public fun <S> all(promise: Array<out Promise<S>>): Promise<Array<out S>>\n\n        public fun <S> race(promise: Array<out Promise<S>>): Promise<S>\n\n        public fun reject(e: Throwable): Promise<Nothing>\n\n        public fun <S> resolve(e: S): Promise<S>\n        public fun <S> resolve(e: Promise<S>): Promise<S>\n    }\n}\n\n// It's workaround for KT-19672 since we can fix it properly until KT-11265 isn't fixed.\ninline fun <T, S> Promise<Promise<T>>.then(\n    noinline onFulfilled: ((T) -> S)?\n): Promise<S> {\n    return this.unsafeCast<Promise<T>>().then(onFulfilled)\n}\n\ninline fun <T, S> Promise<Promise<T>>.then(\n    noinline onFulfilled: ((T) -> S)?,\n    noinline onRejected: ((Throwable) -> S)?\n): Promise<S> {\n    return this.unsafeCast<Promise<T>>().then(onFulfilled, onRejected)\n}\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uBAqFA,+C;iBCoFA,e;;;iCC7BwC,qB;;WAIP,gB;;;;;;;;;;eCmMjC,I;eClUA,a;;;;;;;;;;;;;;;;;ECLI,iC;IAAQ,OAAA,SAAK,c;G;EAOb,gC;IAAQ,OAAA,SAAK,a;G;EAOb,gC;IAAQ,OAAA,SAAK,a;G;EAEjB,mC;IAEI,kBAA8B,QAAZ,WAAY,EAAQ,GAAR,C;IAC9B,IAAI,cAAc,CAAlB,C;MACI,OAAO,YAAO,WAAP,C;IAEX,kBAA8B,QAAZ,WAAY,EAAQ,GAAR,EAAa,cAAc,CAAd,IAAb,C;IAC9B,IAAI,cAAc,CAAlB,C;MAEoB,WAAZ,WCyLoF,WDzL9D,CCyL8D,EDzL3D,WCyL2D,C;MDxLxE,iBAAU,cAAc,CAAd,I;MAF1B,OAAO,oBAEH,WCqLqE,WAAU,UAAV,CDvLlE,C;KAMK,aAAZ,WCoLwF,WDpLlE,CCoLkE,EDpL/D,WCoL+D,C;IDnL5E,mBAAU,cAAc,CAAd,I;IAAV,aAAZ,WCmLwF,WAAU,YAAV,EDnLjD,WCmLiD,C;IDlL5E,mBAAU,cAAc,CAAd,I;IAH1B,OAAO,2BAGH,WC+KyE,WAAU,YAAV,CDlLtE,C;EAKX,C;EAGA,0B;IACI,IAAI,iBJ6O4C,YAAU,CI7O1D,C;MACI,OAAO,kB;IACX,IAAI,iBJ2O4C,YAAU,CI3O1D,C;MACI,OAAO,qBAAW,GAAX,GAAiB,iB;IAC5B,OAAO,qBAAW,GAAX,GAAiB,iBAAjB,GAA2B,GAA3B,GAAiC,iB;EAC5C,C;EAEA,2C;IEsDW,SFpD0B,aAAX,UAAW,EAAa,kBAAb,C;IAAjC,sBACQ,KAAK,CAAT,GACI,kBADJ,GAGI,8BAAkB,EAAlB,C;IAGR,IAAI,iBJ6N4C,YAAU,CI7N1D,C;MACI,OAAO,e;IE4CJ,WF1CyB,aAAX,UAAW,EAAa,qBAAW,GAAX,GAAiB,iBAA9B,C;IAAhC,qBACQ,OAAK,CAAT,GACI,yBAAoB,iBAApB,MADJ,GAGI,8BAAkB,IAAlB,C;IAGR,IAAI,iBJmN4C,YAAU,CInN1D,C;MACI,OAAO,c;IEkCJ,WF/BW,aAAX,UAAW,EAAa,qBAAW,GAAX,GAAiB,iBAAjB,GAA2B,GAA3B,GAAiC,iBAA9C,C;IAAlB,OACQ,OAAK,CAAT,GACsB,gCAAgB,GAAhB,CAAlB,SAAyC,iBAAzC,MADJ,GAGI,8BAAkB,IAAlB,C;EAEZ,C;;;;;;;;;;EG5EA,+B;IAOI,0BAEI,OAAO,YAAO,IAAP,CAAP,C;IAEJ,mBAEI,OAAO,YAAP,C;IAEJ,6BAEI,OAAO,qCAAP,C;IAEJ,mCACuD,SAAO,IAAP,C;G;yDAEvD,Y;IAEI,qBAAgB,YAAO,IAAP,C;IAChB,cAAS,Y;IACT,wBAAmB,qC;IACnB,8BAAyB,I;EAC7B,C;;;SAMI,Y;MAAQ,OAAA,uBAAiB,uB;K;SACzB,iB;MACI,iDAAyB,K;IAC7B,C;;;;SAIA,Y;MAAQ,OAAA,gBAAU,uB;K;SAClB,iB;MACI,0CAAkB,K;IACtB,C;;;;SAIA,Y;MAAQ,OAAA,0BAAoB,uB;K;SAC5B,iB;MACI,oDAA4B,K;IAChC,C;;;;SASA,Y;MAAQ,OAAA,gCAA0B,uB;K;SAClC,iB;MACI,0DAAkC,K;IACtC,C;;;;;;;ECjEkB,8C;IAAC,oC;G;;;SAGnB,Y;MAAQ,OAAA,qBAAiB,c;K;;;;SAGzB,Y;MAAQ,OAAA,qBAAiB,O;K;;;;SAGzB,Y;MAAQ,OAAA,qBAAiB,iB;K;;;;SAGzB,Y;MAAQ,OAAA,qBAAiB,uB;K;;;;;;;ECND,gG;IAC5B,4C;IACA,8B;IACA,kD;IACA,8D;G;;SAHA,Y;MAAA,mC;K;;;SACA,Y;MAAA,4B;K;;;SACA,Y;MAAA,sC;K;;;SACA,Y;MAAA,4C;K;;0DAUA,2B;IAA6C,+BAAW,aAAa,eAAb,CAAX,C;G;uDAE7C,qB;IAAoC,iCAChB,kBADgB,EAEvB,SAFuB,EAGb,qBAHa,EAIP,2BAJO,C;G;;;;;;EAVpC,2C;IAAA,+D;IACgB,kCACI,YAAO,IAAP,CADJ,EAEH,YAFG,EAGO,qCAHP,EAIa,IAJb,C;IADhB,Y;G;+CAZJ,Y;IAOI,yB;G;+CAPJ,Y;IAQI,kB;G;+CARJ,Y;IASI,4B;G;+CATJ,Y;IAUI,kC;G;iDAVJ,2E;IAAA,iCAOI,6DAPJ,EAQI,wCARJ,EASI,sEATJ,EAUI,wFAVJ,C;G;6CAAA,Y;IAAA,OAOI,4EAPJ,IAQI,0CARJ,KASI,8DATJ,KAUI,0EAVJ,O;G;6CAAA,Y;IAAA,c;IAOI,8D;IACA,uD;IACA,iE;IACA,uE;IAVJ,a;G;2CAAA,iB;IAAA,4IAOI,sDAPJ,IAQI,wCARJ,IASI,4DATJ,IAUI,wEAVJ,I;G;ECcA,yB;IAUI,oCAEI,OAAO,iBAAP,C;G;wDAEJ,4B;IAEuB,gBAAnB,iC;;MC6HJ,OAAO,IAAP,C;QACI,UAAU,gC;QACV,UAAmB,GD9HC,aAAqB,uBAArB,mB;QC+HpB,IAAI,iCAAc,GAAd,EAAmB,GAAnB,CAAJ,C;UAA6B,kB;;;;ED7HjC,C;+DAEA,mC;IAEI,uBAAwB,oEAAqB,yB;;KAArB,YAAqB,IAArB,G;EAC5B,C;sDAEA,Y;IAEuB,gBAAnB,iC;;MCiHJ,OAAO,IAAP,C;QACI,UAAU,gC;QACV,UDnH4B,iB;QCoH5B,IAAI,iCAAc,GAAd,EAAmB,GAAnB,CAAJ,C;UAA6B,kB;;;;EDnHjC,C;;;SAOI,Y;MAAQ,OAAA,iCAAmB,uBAAM,K;K;;+CAErC,yB;IAGI,IAAI,QAAQ,CAAZ,C;MACI,MAAM,8BAAyB,qCAAzB,C;IACV,eAAe,iCAAmB,uBAAnB,WAAyB,0BAAU,MAAO,OAA1C,C;IACf,aAAsB,I;IACtB,IAAI,aAAa,IAAb,IAAqB,QAAQ,QAAS,KAA1C,C;MACI,SAAS,qBAAS,KAAT,C;IACb,IAAI,MAAO,uBAAP,IAAiC,8CAAqB,IAA1D,C;MACI,SAAS,I;IACb,IAAI,WAAW,IAAf,C;MACI,WAAW,iCAAmB,uBAAnB,WAAyB,MAAO,cAAhC,C;IACf,IAAI,aAAa,IAAb,IAAqB,QAAQ,QAAS,KAA1C,C;MACI,SAAS,qBAAS,KAAT,C;IACb,IAAI,MAAO,uBAAP,IAAiC,8CAAqB,IAA1D,C;MACI,SAAS,I;IACb,IAAI,WAAW,IAAf,C;MACI,OAAO,MAAG,KAAH,M;IACX,OAAO,M;EACX,C;+CAOA,qC;IAII,OAAA,MAAO,iBAAiB,gBACpB,wBAAW,KAAX,EAAkB,MAAlB,CADoB,EAEpB,UAFoB,EAGpB,0BAAU,MAAO,OAHG,C;G;wDAO5B,iB;IAKI,0CAAiB,IAAjB,EAAuB,KAAvB,C;G;wDAEJ,qB;IAEI,0CAAiB,IAAjB,EAAuB,KAAvB,EAA8B,OAAO,EAAP,CAA9B,C;G;wDAEJ,yB;IAEI,0CAAiB,IAAjB,EAAuB,KAAvB,EAA8B,UAAO,EAAP,EAAW,EAAX,EAA9B,C;G;uDAEJ,6B;IAEI,0CAAiB,IAAjB,EAAuB,KAAvB,EAA8B,UAAO,EAAP,EAAW,EAAX,EAAe,EAAf,EAA9B,C;G;wDAEJ,iC;IAEI,0CAAiB,IAAjB,EAAuB,KAAvB,EAA8B,UAAO,EAAP,EAAW,EAAX,EAAe,EAAf,EAAmB,EAAnB,EAA9B,C;G;wDAEJ,qC;IAEI,0CAAiB,IAAjB,EAAuB,KAAvB,EAA8B,UAAO,EAAP,EAAW,EAAX,EAAe,EAAf,EAAmB,EAAnB,EAAuB,EAAvB,EAA9B,C;G;+DAEJ,iB;IAMI,wDAA+B,IAA/B,EAAqC,KAArC,C;G;+DAEJ,iB;IAEI,wDAA+B,IAA/B,EAAqC,KAArC,C;G;+DAEJ,iB;IAEI,wDAA+B,IAA/B,EAAqC,KAArC,C;G;+DAEJ,iB;IAEI,wDAA+B,IAA/B,EAAqC,KAArC,C;G;+DAEJ,iB;IAEI,wDAA+B,IAA/B,EAAqC,KAArC,C;G;EAQkB,uD;IAGlB,kC;IAFA,0B;IACA,gB;G;sDAGA,Y;IACI,6BAAS,IAAT,C;G;8DAEJ,kB;IACI,OAAA,eAAS,oBAAW,UAAX,EAAgB,MAAhB,C;G;oDAGb,iB;IACI,IAAI,SAAS,KAAb,C;MAAoB,OAAO,I;IAC3B,IAAI,qDAAJ,C;MAAgC,OAAO,K;IAEvC,IAAI,yBAAY,KAAM,WAAlB,CAAJ,C;MAAgC,OAAO,K;IACvC,IAAI,eAAO,KAAM,MAAjB,C;MAAsB,OAAO,K;IAE7B,OAAO,I;EACX,C;sDAEA,Y;IACI,aAAsB,SAAT,eAAS,C;IACtB,SAAS,MAAK,MAAL,QAAc,UAAd,I;IACT,OAAO,M;EACX,C;;;;;;EAKkB,mE;IAIlB,kC;IAHA,0B;IACA,gB;IACA,8B;G;sDAGA,Y;IACI,6BAAS,IAAT,C;G;8DAEJ,kB;IACI,OAAA,eAAS,oBAAW,UAAX,EAAgB,iBAAhB,EAA4B,MAA5B,C;G;oDAGb,iB;IACI,IAAI,SAAS,KAAb,C;MAAoB,OAAO,I;IAC3B,IAAI,qDAAJ,C;MAAgC,OAAO,K;IAEvC,IAAI,yBAAY,KAAM,WAAlB,CAAJ,C;MAAgC,OAAO,K;IACvC,IAAI,eAAO,KAAM,MAAjB,C;MAAsB,OAAO,K;IAC7B,IAAI,2BAAc,KAAM,aAApB,CAAJ,C;MAAoC,OAAO,K;IAE3C,OAAO,I;EACX,C;sDAEA,Y;IACI,aAAsB,SAAT,eAAS,C;IACtB,SAAS,MAAK,MAAL,QAAc,UAAd,I;IACT,SAAS,MAAK,MAAL,QAAyB,SAAX,iBAAW,CAAzB,I;IACT,OAAO,M;EACX,C;;;;;;EAQ6C,uE;IAC7C,0B;IACA,oB;G;oEAGA,Y;IACI,6BAAS,IAAT,C;G;4EAEJ,kB;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,MAAlB,C;G;wFAEb,sB;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,OAAO,EAAP,CAAlB,EAA8B,MAA9B,C;G;yFAEb,c;IACI,OAAA,eAAS,6BAAoB,YAApB,EAA2B,EAA3B,C;G;;;;;;wEAfjB,Y;IACI,sB;G;wEADJ,Y;IAEI,mB;G;wEAFJ,2B;IAAA,wDACI,gDADJ,EAEI,uCAFJ,C;G;oEAAA,Y;IAAA,c;IACI,2D;IACA,wD;IAFJ,a;G;kEAAA,iB;IAAA,4IACI,gDADJ,IAEI,0CAFJ,I;G;EAkByC,uE;IACrC,0B;IACA,oB;G;oEAGA,Y;IACI,6BAAS,IAAT,C;G;4EAEJ,kB;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,MAAlB,C;G;wFAEb,0B;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,UAAO,EAAP,EAAW,EAAX,EAAlB,EAAkC,MAAlC,C;G;yFAEb,kB;IACI,OAAA,eAAS,6BAAoB,YAApB,EAA2B,EAA3B,EAA+B,EAA/B,C;G;;;;;;wEAfjB,Y;IACI,sB;G;wEADJ,Y;IAEI,mB;G;wEAFJ,2B;IAAA,wDACI,gDADJ,EAEI,uCAFJ,C;G;oEAAA,Y;IAAA,c;IACI,2D;IACA,wD;IAFJ,a;G;kEAAA,iB;IAAA,4IACI,gDADJ,IAEI,0CAFJ,I;G;EAkByC,uE;IACrC,0B;IACA,oB;G;oEAGA,Y;IACI,6BAAS,IAAT,C;G;4EAEJ,kB;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,MAAlB,C;G;wFAEb,8B;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,UAAO,EAAP,EAAW,EAAX,EAAe,EAAf,EAAlB,EAAsC,MAAtC,C;G;yFAEb,sB;IACI,OAAA,eAAS,4BAAoB,YAApB,EAA2B,EAA3B,EAA+B,EAA/B,EAAmC,EAAnC,C;G;;;;;;wEAfjB,Y;IACI,sB;G;wEADJ,Y;IAEI,mB;G;wEAFJ,2B;IAAA,wDACI,gDADJ,EAEI,uCAFJ,C;G;oEAAA,Y;IAAA,c;IACI,2D;IACA,wD;IAFJ,a;G;kEAAA,iB;IAAA,4IACI,gDADJ,IAEI,0CAFJ,I;G;EAmByC,uE;IACrC,0B;IACA,oB;G;oEAGA,Y;IACI,6BAAS,IAAT,C;G;4EAEJ,kB;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,MAAlB,C;G;wFAEb,kC;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,UAAO,EAAP,EAAW,EAAX,EAAe,EAAf,EAAmB,EAAnB,EAAlB,EAA0C,MAA1C,C;G;yFAEb,0B;IACI,OAAA,eAAS,6BAAoB,YAApB,EAA2B,EAA3B,EAA+B,EAA/B,EAAmC,EAAnC,EAAuC,EAAvC,C;G;;;;;;wEAfjB,Y;IACI,sB;G;wEADJ,Y;IAEI,mB;G;wEAFJ,2B;IAAA,wDACI,gDADJ,EAEI,uCAFJ,C;G;oEAAA,Y;IAAA,c;IACI,2D;IACA,wD;IAFJ,a;G;kEAAA,iB;IAAA,4IACI,gDADJ,IAEI,0CAFJ,I;G;EAmByC,uE;IACrC,0B;IACA,oB;G;oEAGA,Y;IACI,6BAAS,IAAT,C;G;4EAEJ,kB;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,MAAlB,C;G;wFAEb,sC;IACI,OAAA,eAAS,oBAAW,YAAX,EAAkB,UAAO,EAAP,EAAW,EAAX,EAAe,EAAf,EAAmB,EAAnB,EAAuB,EAAvB,EAAlB,EAA8C,MAA9C,C;G;yFAEb,8B;IACI,OAAA,eAAS,6BAAoB,YAApB,EAA2B,EAA3B,EAA+B,EAA/B,EAAmC,EAAnC,EAAuC,EAAvC,EAA2C,EAA3C,C;G;;;;;;wEAfjB,Y;IACI,sB;G;wEADJ,Y;IAEI,mB;G;wEAFJ,2B;IAAA,wDACI,gDADJ,EAEI,uCAFJ,C;G;oEAAA,Y;IAAA,c;IACI,2D;IACA,wD;IAFJ,a;G;kEAAA,iB;IAAA,4IACI,gDADJ,IAEI,0CAFJ,I;G;;;;;;;;EEnRY,qF;IAAA,oD;IAAS,uB;G;;;SAET,Y;MAAQ,iB;K;;8EAEZ,iB;IACI,IAAI,QAAQ,6BAAZ,C;MACI,gCAAiB,K;IACrB,OAAO,E;EACX,C;;;;;4DAXR,2B;IAEI,yBAAqB,EAArB,C;IACA,+E;IAUA,oBAAO,OAAP,EAAgB,CAAhB,EAAmB,MAAnB,C;IACA,OAAO,gB;EACX,C;;;;;;EC7BJ,mC;IAAA,uC;IA6CI,yBAA8B,OAC1B,GAAA,oCAAuB,kBAAvB,EAA4C,oCAA5C,CAD0B,EAE1B,GAAA,oCAAuB,oBAAvB,EAA8C,oCAA9C,CAF0B,EAG1B,GAAA,oCAAuB,oBAAvB,EAA8C,oCAA9C,CAH0B,EAI1B,GAAA,oCAAuB,sBAAvB,EAAgD,oCAAhD,CAJ0B,EAK1B,GAAA,oCAAuB,oBAAvB,EAA8C,oCAA9C,CAL0B,E;G;qDAQ9B,uC;IASc,Q;IARV,aAAa,mBAAc,OAAQ,OAAR,GAAiB,CAAjB,IAAd,C;IACb,6BAA6B,C;IAC7B,oBAAmC,I;IACnC,yBAAwC,I;IACxC,0BAAyC,I;IACzC,cAAc,K;IACd,eAAe,K;IACf,YAAY,C;IACF,wB;IAAV,OAAU,cAAV,C;MAAU,8B;MAEF,Y;QACI,IAAI,MAAK,EAAT,C;UACI,IAAI,mBAAQ,QAAQ,CAAR,IAAR,MAAsB,EAA1B,C;YACI,MAAO,gBAAO,EAAP,C;UACX,UAAU,K;;UAEV,MAAO,gBAAO,CAAP,C;WAEf,a;QACI,IAAI,MAAK,EAAL,IAAY,MAAK,GAArB,C;UACI,mBAAsE,KAAnD,OAAQ,WAAY,sBAAZ,EAAoC,KAApC,CAA2C,C;UACtE,yBAAyB,QAAQ,CAAR,I;UAGrB,0B;YAAyB,gBAAgB,Y;eACzC,+B;YAA8B,qBAAqB,Y;eACnD,gC;YAA+B,sBAAsB,Y;SAG7D,IAAI,MAAK,GAAT,C;UACI,gBAAsB,I;UACtB,eAAwC,YAAX,SAAd,aAAc,CAAW,C;UACxC,IAAI,aAAa,IAAb,IAAqB,UAAW,KAAX,GAAkB,QAA3C,C;YACI,YAAY,uBAAW,QAAX,C;UAChB,IAAI,iBAAJ,C;YACI,MAAO,gBAAO,GAAP,CAAY,gBAAO,aAAP,CAAsB,gBAAO,GAAP,C;;YAEzC,MAAO,gBAAO,uBAAgB,SAAhB,EAA2B,kBAA3B,EAA+C,mBAA/C,EAAoE,MAApE,CAAP,C;UACX,WAAW,K;UACX,gBAAgB,I;UAChB,qBAAqB,I;UACrB,sBAAsB,I;gBAG9B,UAAK,EAAL,C;QACI,UAAU,I;WAEd,UAAK,GAAL,C;QACI,WAAW,I;QACX,yBAAyB,QAAQ,CAAR,I;;QAGzB,MAAO,gBAAO,CAAP,C;;MAGf,qB;;IAEJ,OAAO,MAAO,W;EAClB,C;wDAEA,8C;IAOQ,gB;IADJ,IAAI,kBAAJ,C;MACI,uDAAgB,UAAhB,iCACa,CADb,EACgB,UADhB,EAC4B,WAD5B,EACyC,MADzC,kB;QAEY,a;QAEhB,IAAI,iCAAJ,C;MACI,OAAO,CAAE,kBAAS,MAAT,C;IACb,OAAO,CAAE,W;EACb,C;;;;;;;EAhIJ,+C;IAAA,8C;MAAA,6B;KAAA,uC;G;ECEA,kC;IAAA,sC;IAmCI,2BACgC,Q;IAChC,2BAAgC,Q;IAChC,yBAA8B,M;IAC9B,2BAAgC,Q;IAEhC,6BACkC,U;G;oDAElC,kD;IAgBiB,IAAN,I;IATP,IAAI,uBAAJ,C;MACI,IAAI,qCAAJ,C;QACI,OAAO,KAAM,kBAAS,MAAT,C;MACjB,OAAO,KAAM,W;KAGjB,gBAAgB,qCAA8B,WAA9B,C;IAChB,2BAA2B,gDAAyC,WAAzC,C;IAEpB,QAAM,UAAN,C;WACH,Q;QAA6C,OAAtB,6CAAsB,sBACzC,KADyC,EAEzC,SAFyC,EAGzC,oBAHyC,EAIzC,MAJyC,C;QAA7C,K;WAMA,Q;QAKE,OALqB,6CAAsB,4BACnC,eAAN,KAAM,CADmC,EAEnC,eAAN,KAAM,CAFmC,EAGzC,SAHyC,EAIzC,oBAJyC,CAK3C,kBAAS,MAAT,C;QALF,K;WAMA,M;QAKE,OALmB,6CAAsB,0BACjC,eAAN,KAAM,CADiC,EAEjC,eAAN,KAAM,CAFiC,EAGvC,SAHuC,EAIvC,oBAJuC,CAKzC,kBAAS,MAAT,C;QALF,K;WAMA,Q;QAKE,OALqB,6CAAsB,4BACnC,eAAN,KAAM,CADmC,EAEnC,eAAN,KAAM,CAFmC,EAGzC,SAHyC,EAIzC,oBAJyC,CAK3C,kBAAS,MAAT,C;QALF,K;WAMA,U;QACK,OADoB,6CAAsB,8BAA2B,eAAN,KAAM,CAA3B,CAC1C,kBAAS,MAAT,C;QADL,K;cAEc,OAAN,KAAM,W;QA3BX,K;;IAAP,W;EA6BJ,C;qEAEA,uB;IAOI,IAM4D,I;IAX5D,IAAI,uBAAuB,CAAa,WAAZ,WAAY,EAAW,GAAX,CAAxC,C;MACI,OAAO,U;IACX,eAA2B,QAAZ,WAAY,EAAQ,GAAR,C;IAC3B,IAAI,WAAW,CAAX,IAAgB,YAAW,CAAX,SAAgB,WAAY,OAAhD,C;MACI,OAAO,U;IACX,2B;IACA,aAAa,Q;IACb,IAAI,uBAAY,MAAZ,MAAuB,EAA3B,C;MACI,uB;KACJ,OAAO,WAAY,OAAZ,GAAqB,MAArB,IAAmD,QAApB,uBAAY,MAAZ,CAAoB,CAA1D,C;MACI,uB;;IACJ,OAAO,CAAqD,mBAAzC,mBAAZ,WAAY,EAAY,QAAZ,EAAsB,MAAtB,CAA8B,WAAW,CAArD,mBAAsE,U;EACjF,C;gFAEA,uB;IAEI,IAAI,uBAAuB,CAAa,WAAZ,WAAY,EAAW,GAAX,CAAxC,C;MACI,OAAO,K;IACX,OAAmB,SAAZ,WAAY,EAAS,IAAT,C;EAEvB,C;;;;;;;EAjHJ,8C;IAAA,6C;MAAA,4B;KAAA,sC;G;;;;;;;;;;;;;;;;;;;;;;ECD6B,+C;IACzB,8B;IACA,kB;G;;SADA,Y;MAAA,4B;K;;;;SAKI,Y;MAAQ,OAAA,WAAK,K;K;;kDAEjB,iB;IAAwC,+BAAK,KAAL,C;G;;;;;;ECRH,sC;IAGrC,8BACiD,KAAK,4CAAL,C;G;;;SADjD,Y;aCkCwF,iC;K;;;;SD5BpF,Y;MAAQ,OAAA,mBAAK,M;K;;qDAEjB,iB;IACI,OAAA,mBAAK,OAAL,aAAY,KAAZ,C;G;;;SAGA,Y;MAAQ,OAAA,mBAAK,OAAO,K;K;;EAX8B,iF;IAAA,mB;MAClD,6C;IACJ,C;G;;;;;;EEwCyC,wD;IACzC,8B;MAAA,iBACsC,I;IACtC,qC;IAFA,8C;G;kDAOA,Y;IAIiB,UAoBC,MApBD,EAoBA,M;IAvBb,enB8BgD,gB;ImB7BhD,cAAc,sB;IACd,aAAa,I;IACA,OAAW,aAAX,eAAW,CAAX,W;IAAb,OAAa,cAAb,C;MAAa,sB;MACA,0BAAL,IAAK,EAAW,GAAX,C;MAAL,W;QlB4G2B,U;QkB5GH,gBlB4GyB,KAAtB,+BkB5GH,IlB4GG,uBAAsB,CAAO,WkB5GhC,EAAe,GAAf,C;OAA5B,W;QACI,QAAS,WAAQ,MAAJ,GAAY,IAAZ,GAAsB,OAAQ,WAAlC,C;QACT,OAAQ,mBAAU,CAAV,C;QACR,SAAS,I;QACT,Q;OAEJ,IAAI,CAAC,MAAL,C;QACI,OAAQ,gBAAO,IAAP,C;MACZ,OAAQ,gBACK,aAAL,IAAK,EAAW,GAAX,CADL,GAEA,IbgJ6D,WahJ9C,CbgJ8C,CalJ7D,GAIA,IAJA,C;MAMR,SAAS,K;;IAEb,QAAS,WAAI,OAAQ,WAAZ,C;IAGI,UAAC,SAAI,QAAS,UAAb,GAAwB,IAAxB,GAAkC,qBAAS,CAAT,CAAnC,YAAuD,oBAAvD,O;IAAA,mB;MACN,MAAM,8BAAyB,mCAAzB,C;KADb,aAAa,M;IAGb,IAAI,iCAAkB,IAAlB,IAA0B,gBAAU,6BAAV,CAA9B,C;MACI,MAAM,8BAAyB,4CAAiC,qBAAS,CAAT,CAAjC,kDAA+E,6BAA/E,QAAzB,C;KAEV,OAAO,SAAK,MAAL,EAAa,QAAS,iBAAQ,CAAR,EAAW,QAAS,KAApB,CAAtB,C;EACX,C;;;;;;ECnFyB,uD;IACzB,8B;MAAA,iBACsC,I;IAEtC,0CAA+B,cAA/B,C;IAHA,sC;IAEA,kB;G;+CAGA,Y;IAAkC,kB;G;;;;;;ECZtC,mC;G;+CAEI,Y;IACI,6BAAS,IAAT,C;G;;;;;;ECDR,gC;IAAA,oC;G;4CAGI,Y;IAAkC,S;G;oDAElC,kB;IAAyC,S;G;;;;;;;EAL7C,4C;IAAA,2C;MAAA,0B;KAAA,oC;G;EpBMiC,wE;IAwB7B,6C;IArBA,yB;MAAA,YAMqB,U;IAErB,oC;MAAA,uBAEoC,K;IAEpC,kC;IAdA,oB;IAEA,0B;IAQA,gD;G;6CAMA,Y;IACI,6BAAS,IAAT,C;G;qDAEJ,kB;IACI,OAAA,mEAAa,WAAb,EAAqB,cAArB,EAAgC,yBAAhC,EAAsD,0BAAU,MAAO,OAAvE,CAA+E,W;G;EAGnF,2C;IAAA,+C;IAEI,qCAC0C,+CACvB,EADuB,EAEvB,EAFuB,EAGnB,CAHmB,EAIlB,CAJkB,C;IAO1C,uCACsC,cAClC,SAAQ,+CACW,EADX,EAEW,EAFX,EAGe,CAHf,EAIgB,CAJhB,CAAR,CADkC,E;G;mEAStC,2D;IAkBiC,IAAN,I;IACnB,IADyB,SACzB,gB;MAAiB,6BAAsB,eAAP,MAAO,CAAtB,C;;MACT,4BAAqB,eAAP,MAAO,CAArB,EAAiC,SAAjC,C;IAFZ,Y;IAIA,IAAI,CAAC,oBAAL,C;MACI,0BAAmB,CAAnB,C;IAEJ,QAAQ,qCAAwB,MAAxB,C;IAER,wBAAwB,CAAE,iBAAQ,GAAR,C;IAC1B,IAAI,oBAAoB,CAApB,KAA0B,CAAE,iBAAF,IAAsB,CAAtB,IAA2B,CAAE,OAAF,GAAW,CAAE,iBAAlE,CAAJ,C;MACI,OAAO,CAAE,W;IAEb,4BAA4B,aAAE,CAAF,MAAQ,EAAR,IAAe,aAAE,CAAF,MAAQ,E;IAEnD,IAAI,qBAAqB,CAAzB,C;MACI,cAAE,iBAAF,EAAyB,UAAF,CAAE,cAAzB,C;MACA,IAAI,CAAE,kBAAF,GAAsB,CAA1B,C;QACI,UAAU,oBAAoB,CAApB,GAAwB,CAAE,kBAA1B,I;QACV,OAAO,MAAM,CAAE,OAAf,C;UACI,CAAE,gBAAO,GAAP,EAAc,UAAF,CAAE,cAAd,C;UACF,aAAO,CAAP,GAAW,CAAE,kBAAb,K;;;MAIR,oBAAoB,CAAE,O;IAE1B,IAAI,CAAE,iBAAF,GAAqB,CAAzB,C;MACI,YAAU,oBAAoB,CAAE,iBAAtB,I;MACV,OAAW,qBAAJ,GAA2B,QAAM,CAAjC,GAAwC,QAAM,CAArD,C;QACI,CAAE,gBAAO,KAAP,EAAc,UAAF,CAAE,cAAd,C;QACF,gBAAO,CAAE,iBAAT,I;;KAGR,OAAO,CAAE,W;EAEb,C;8EAEA,kB;IAEI,QAAY,UAAU,IAAd,GAAoB,IAApB,GAA8B,+CAAgC,MAAO,SAAvC,C;IACtC,OAAO,gBAAK,kC;EAChB,C;8DAEA,6B;IAWI,cAAc,SAAS,G;IACvB,qBC6NsC,MAAW,KD7NxB,MC6NwB,C;ID5NpC,QAAI,CAAW,S;IAA5B,QC6Q6C,MAAW,KD7QhD,IC6QgD,EAAU,CAAV,C;ID5QxD,IAAI,cAAa,CAAjB,C;MACI,kBAAkB,C;IACtB,Q;IAEA,IAAI,YAAY,CAAhB,C;MACI,mBAAmB,MAAM,cAAN,IAAwB,C;MAC3C,IAAI,iBAAgB,GAApB,C;QACI,OAAO,kBAAc,GAAd,C;MACX,OAAO,kBAAc,YAAa,WAA3B,C;MACP,0BAAmB,IAAnB,C;WACG,IAAI,oDAAJ,C;MACH,OAAO,kBAAc,MAAO,WAArB,C;;MAEP,gBAA+B,YAAf,cAAe,C;MAC/B,IAAI,qBAAJ,C;QACI,OAAO,kBAAc,GAAd,C;QACP,IAAI,YAAY,CAAhB,C;UACI,IAAK,gBAAO,GAAP,C;UACL,aAAU,CAAV,OAAa,SAAb,M;YACI,IAAK,gBAAO,GAAP,C;SAEb,OAAO,I;OAGX,OAAO,kBAAc,SAAU,WAAxB,C;MACP,IAAI,YAAY,CAAhB,C;QACI,gBAAgB,IAAK,OAAL,GAAc,SAAd,I;QAChB,OAAO,YAAY,CAAnB,C;UACI,IAAK,gBAAO,CAAP,EAAU,GAAV,C;UACL,6B;;QAEJ,IAAK,gBAAO,SAAP,EAAsB,cAAa,CAAjB,GAAoB,IAApB,GAA8B,GAAhD,C;;IAGb,IAAI,OAAJ,C;MACI,IAAK,gBAAO,CAAP,EAAU,GAAV,C;IACT,uBAAgB,IAAhB,C;IACA,OAAO,I;EACX,C;+DAEA,kB;IAEI,WAAW,kBAAc,MAAO,WAArB,C;IACX,uBAAgB,IAAhB,C;IACA,wBAAwB,IAAK,iBAAQ,GAAR,C;IAE7B,IAAS,WAAL,IAAK,EAAgB,GAAhB,EAAkC,IAAlC,CAAT,C;MAC4B,QAAI,IAAK,iBAAQ,GAAR,C;MAAT,QAAuB,IAAK,iBAAQ,GAAR,C;MAApD,wBCq1BoC,MAAW,KAAI,CAAJ,EAAO,CAAP,C;MDp1B/C,eAAqD,MAAtC,IAAK,mBAAU,oBAAoB,CAApB,IAAV,CAAiC,C;MACrD,IAAI,WAAW,CAAX,IAAgB,qBAAqB,CAArC,IAA0C,oBAAoB,iBAAlE,C;QACI,uBAAY,iBAAZ,GAAgC,iBAAhC,GAAoD,CAApD,K;MACJ,IAAI,IAAI,QAAJ,KAAiB,EAArB,C;QACI,OAAO,I;MACX,IAAI,WAAW,CAAf,C;QACI,OAAO,qBAAc,MAAd,EAAsB,CAAC,QAAD,IAAtB,C;;QAEP,OAAO,qBAAc,MAAd,EAAsB,KAAK,QAAL,IAAtB,C;;MAEX,IAAI,oBAAoB,CAAxB,C;QACI,OAAO,I;MACX,mBAAmB,IAAK,O;MACxB,IAAI,SAAS,CAAb,C;QACI,mC;OACJ,IC4JkC,MAAW,KD5JrC,MC4JqC,CD5JzC,GAAc,CAAlB,C;QACI,mC;OAEJ,IAAI,eAAe,EAAnB,C;QACiC,UAAO,IAAK,OAAL,GAAc,iBAAd,GAAkC,CAAlC,I;QAApC,OAAO,qBAAc,MAAd,ECi0ByB,MAAW,KDj0BV,CCi0BU,EAAO,GAAP,CDj0BpC,C;;IAEf,0BAAmB,IAAnB,C;IACA,OAAO,I;EACX,C;mEAEA,gB;IAEI,wBAAwB,IAAK,iBAAQ,GAAR,C;IAC7B,IAAI,oBAAoB,CAAxB,C;MACI,M;IAGJ,aAAU,IAAK,OAAL,GAAc,CAAd,IAAV,OAAiC,iBAAjC,M;MACI,YAAY,gBAAK,CAAL,C;MACZ,IAAI,UAAS,EAAb,C;QACI,IAAK,mBAAU,CAAV,C;QACL,K;OAEJ,IAAI,UAAS,EAAb,C;QACI,IAAK,mBAAU,IAAI,CAAJ,IAAV,C;QACL,K;;EAGZ,C;gEAEA,gB;IAEmB,UAAL,MAAK,EAAL,MAAK,EAAL,M;IAAK,mBAAL,IAAK,C;IAAL,mB;IAAA,kB;IAAA,kB;IAAV,8C;MACI,IAAI,CAAS,QAAR,gBAAK,CAAL,CAAQ,CAAb,C;QACsB,gBAAR,gBAAK,CAAL,C;QAAV,iBAAK,CAAL,EEtMuG,OAA1D,8BAAY,cAAc,YAAW,CAAX,CAAgC,CFsMvG,C;;IAER,OAAO,IAAP,C;MACI,eAAe,IAAK,iBAAQ,GAAR,C;MACpB,IAAI,WAAW,CAAf,C;QACI,K;MACJ,IAAK,kBAAS,QAAT,C;;EAEb,C;yEAEA,kB;IAMI,OAAO,gCAAmB,MAAnB,EAA2B,MAA3B,EAAmC,UAAnC,EAAkD,IAAlD,C;EACX,C;yEAEA,8D;IAqBI,Q;IAHA,eAAyC,M;IACzC,kBAA4C,S;IAE5C,gDAA6B,QAA7B,W;MAA4C,OAAO,+B;KAEvC,QAAI,W;IAAhB,cCgFsC,MAAW,KAAI,CAAJ,C;ID/EjD,WAAW,G;IACX,IAAI,cAAY,CAAhB,C;MACI,YAAU,M;MACV,OAAO,I;WACJ,IAAI,eAAa,IAAjB,C;MACH,YAAU,K;MACV,OAAO,I;KAEX,OAAO,iCACH,SADG,EAEH,UAAO,0BAAsB,QAAtB,EAA8B,SAA9B,EAAyC,oBAAzC,CAAP,EAAuE,IAAvE,EAFG,C;EAIX,C;yEAEA,iB;IAOI,OAAO,gCAAmB,KAAnB,EAA0B,KAA1B,EAAiC,UAAjC,EAAgD,IAAhD,C;EACX,C;yEAEA,6D;IAqBI,Q;IAHA,cAAwC,K;IACxC,kBAA4C,S;IAE5C,gDAA6B,OAA7B,W;MAA2C,OAAO,+B;KAEtC,QAAI,W;IAAhB,cCgCsC,MAAW,KAAI,CAAJ,C;ID/BjD,WAAW,G;IAEP,kBAAY,CAAZ,C;MACI,WAAS,M;MACT,OAAO,I;WAEX,mBAAa,OAAb,C;MACI,WAAS,M;MACT,OAAO,G;WAEX,mBAAa,IAAb,C;MACI,WAAS,K;MACT,OAAO,I;KAIf,OAAO,iCACH,SADG,EAEH,UAAO,0BAAsB,OAAtB,EAA6B,SAA7B,EAAwC,oBAAxC,CAAP,EAAsE,IAAtE,EAFG,C;EAIX,C;uEAEA,wB;IAOI,OAAO,8BAAiB,YAAjB,EAA+B,YAA/B,EAA6C,UAA7C,EAA4D,IAA5D,C;EACX,C;uEAEA,oE;IAqBI,Q;IAHA,qBAA+C,Y;IAC/C,kBAA4C,S;IAE5C,gDAA6B,cAA7B,W;MAAkD,OAAO,+B;KAE7C,QAAI,W;IAAhB,cCxBsC,MAAW,KAAI,CAAJ,C;IDyBjD,WAAW,O;IACX,IAAI,cAAY,KAAhB,C;MACI,kBAAgB,S;MAChB,OAAO,Q;KAEX,IAAI,eAAa,MAAjB,C;MACI,kBAAgB,S;MAChB,OAAO,Q;KAEX,OAAO,iCACH,SADG,EAEH,UAAO,0BAAsB,cAAtB,EAAoC,SAApC,EAA+C,oBAA/C,CAAP,EAA6E,IAA7E,EAFG,C;EAIX,C;2EAGA,6B;IAQI,Q;IAFA,0BAAoD,iB;IAEpD,gDAA6B,mBAA7B,W;MAAuD,OAAO,+B;KAE9D,WAAW,E;IACX,IAAI,sBAAoB,GAAxB,C;MACI,OAAO,G;MACP,sBAAoB,CAAC,mB;KAEzB,IAAI,sBAAoB,UAAxB,C;MAAuC,OAAO,0BAAsB,eAAtB,C;IAC9C,IAAI,sBAAoB,GAAxB,C;MACI,OAAO,0BAAwB,IAAF,GAAO,mBAAP,OAAtB,C;KAEX,IAAI,sBAAoB,IAAxB,C;MACI,cAAc,0BAAsB,mBAAtB,EAAyC,CAAzC,C;MACd,OAAO,iCAA+B,IAAF,UAA7B,EAA2C,OAAO,OAAP,CAA3C,C;KAEX,mBAA4C,YAAzB,MAAM,mBAAN,CAAyB,C;IAC5C,gBAAc,eAAe,E;IAC7B,cAAc,gBAAe,EAAf,QAAoB,E;IAClC,YAAY,iBAAe,EAAf,QAAoB,EAApB,QAAyB,E;IACrC,WAAW,iBAAe,EAAf,QAAoB,EAApB,QAAyB,EAAzB,I;IACX,SAAS,sB;IACT,EAAG,gBAAO,IAAP,C;IACH,IAAI,OAAO,CAAX,C;MAAc,EAAG,gBAAO,IAAP,CAAa,gBAAO,IAAP,C;IAC9B,IAAI,QAAQ,CAAZ,C;MACI,EAAG,gBAAO,KAAP,C;MACH,IAAI,UAAU,CAAV,IAAe,YAAU,CAA7B,C;QACI,EAAG,gBAAO,GAAP,C;QACH,IAAI,UAAU,EAAd,C;UACI,EAAG,gBAAO,GAAP,C;QACP,EAAG,gBAAO,OAAP,C;OAEP,IAAI,YAAU,CAAd,C;QACI,EAAG,gBAAO,GAAP,C;QACH,IAAI,YAAU,EAAd,C;UACI,EAAG,gBAAO,GAAP,C;QACP,EAAG,gBAAO,SAAP,C;OAEP,EAAG,gBAAO,IAAP,C;WACA,IAAI,UAAU,CAAd,C;MACH,EAAG,gBAAO,OAAP,C;MACH,IAAI,YAAU,CAAd,C;QACI,EAAG,gBAAO,GAAP,C;QACH,IAAI,YAAU,EAAd,C;UACI,EAAG,gBAAO,GAAP,C;QACP,EAAG,gBAAO,SAAP,C;OAEP,EAAG,gBAAO,MAAP,C;WACA,IAAI,YAAU,CAAd,C;MACH,EAAG,gBAAO,SAAP,CAAgB,gBAAO,IAAP,C;KAEvB,OAAO,0BAAsB,EAAG,WAAzB,C;EACX,C;6EAEA,a;IACI,IAAM,WAAF,CAAE,CAAN,C;MACI,OAAW,IAAI,CAAR,GAAW,QAAX,GAAyB,S;KAEpC,OAAa,QAAF,CAAE,CAAN,GAAe,KAAf,GAA0B,I;EACrC,C;;;;;;;EAtaJ,uD;IAAA,sD;MAAA,qC;KAAA,+C;G;EA0a0B,qH;IACtB,6C;IAEA,6C;IAEA,wC;IAEA,0C;G;;;;;;;;;;;+CA3cR,Y;IAGI,kB;G;+CAHJ,Y;IAKI,qB;G;+CALJ,Y;IAaI,gC;G;iDAbJ,mD;IAAA,iCAGI,wCAHJ,EAKI,iDALJ,EAaI,kFAbJ,C;G;6CAAA,Y;IAAA,c;IAGI,uD;IAEA,0D;IAQA,qE;IAbJ,a;G;2CAAA,iB;IAAA,4IAGI,wCAHJ,IAKI,8CALJ,IAaI,oEAbJ,I;G;EAgdA,4B;IAMiB,IAAN,I;IAAA,QAAM,SAAN,C;WACH,E;WAAA,E;WAAA,E;WAAA,E;WAAA,E;WAAA,E;WAAA,E;WAAA,E;WAAA,E;WAAA,E;QAAoD,W;QAApD,K;cACQ,Y;QAFL,K;;IAAP,W;EAIJ,C;;;qCqBldI,Y;IAEI,6BAAS,IAAT,C;G;6CAEJ,kB;IAEI,6BAAS,MAAT,C;G;;;;;;;;2DCdJ,wC;IAG0B,sB;MAAA,SAAkB,I;WAH5C,+F;G;6DAQA,sB;IAEI,iCAAa,EAAb,EAAiB,MAAjB,C;G;qDAAA,wC;IADyB,sB;MAAA,SAAkB,I;WAD/C,yF;G;kDAIA,c;IAEI,0CAAsB,EAAtB,C;G;;;;;;;;2DAMJ,4C;IAImC,sB;MAAA,SAAkB,I;WAJrD,uG;G;6DAYA,0B;IAEI,iCAAa,EAAb,EAAiB,EAAjB,EAAqB,MAArB,C;G;qDAAA,4C;IADkC,sB;MAAA,SAAkB,I;WADxD,iG;G;kDAIA,kB;IAEI,0CAAsB,EAAtB,EAA0B,EAA1B,C;G;;;;;;;;2DAMJ,gD;IAI4C,sB;MAAA,SAAkB,I;WAJ9D,+G;G;6DAYA,8B;IAEI,iCAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,MAAzB,C;G;qDAAA,gD;IAD2C,sB;MAAA,SAAkB,I;WADjE,yG;G;kDAIA,sB;IAEI,0CAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;G;;;;;;;;2DAOJ,oD;IAIqD,sB;MAAA,SAAkB,I;WAJvE,uH;G;6DAYA,kC;IAEI,iCAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,MAA7B,C;G;qDAAA,oD;IADoD,sB;MAAA,SAAkB,I;WAD1E,iH;G;kDAIA,0B;IAEI,0CAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;G;;;;;;;;2DAMJ,wD;IAI8D,sB;MAAA,SAAkB,I;WAJhF,+H;G;6DAYA,sC;IAKI,iCAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,MAAjC,C;G;qDAAA,wD;IAFA,sB;MAAA,SAAkB,I;WAHtB,yH;G;kDAOA,8B;IAEI,0CAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;G;;;;;;EC9G0B,0D;IAQ9B,kC;IAPA,wB;IAIA,4B;G;4DAKA,kB;IAGS,kBAAD,M;IAFJ,QAAQ,0BAAU,MAAO,O;IACzB,OAAO,MAAO,iBAAiB,gBAC3B,WAAC,4EAAD,oCAAwC,CAAxC,6BAA8C,cAAQ,WAD3B,EAE3B,gBAF2B,EAEhB,CAFgB,C;EAInC,C;;;;;;ECvBuB,sC;IAAC,oB;G;6CAExB,Y;IAAkC,OAAA,YAAM,W;G;qDAExC,kB;IAAyC,OAAA,YAAM,W;G;;;;;;ECL1B,4C;IACrB,wB;IACA,sB;IACA,sB;G;iCAWA,Y;IAAmC,oB;G;gCACnC,Y;IAAkC,mB;G;gCAClC,Y;IAAkC,mB;G;8BAElC,Y;IAAkC,kB;G;;;;;;EAblC,sC;IAAA,gD;IAEI,mBAAK,QAAL,EAAe,EAAf,EAAmB,EAAnB,C;IAFJ,Y;G;EAIA,iD;IAAA,gD;IAGI,mBAAK,QAAL,EAAe,OAAf,EAAwB,EAAxB,C;IAHJ,Y;G;gCATJ,Y;IACI,oB;G;gCADJ,Y;IAEI,mB;G;gCAFJ,Y;IAGI,mB;G;kCAHJ,sC;IAAA,kBACI,8CADJ,EAEI,2CAFJ,EAGI,2CAHJ,C;G;8BAAA,Y;IAAA,c;IACI,yD;IACA,wD;IACA,wD;IAHJ,a;G;4BAAA,iB;IAAA,4IACI,4CADJ,IAEI,0CAFJ,IAGI,0CAHJ,I;G;;ECQqC,6F;IACjC,8B;MAAA,iBACsC,I;IAEtC,wB;MAAA,WAAsC,I;IACtC,wB;MAAA,WAAyC,I;IAJzC,sC;IAEA,sC;IACA,0B;IACA,0B;G;EAQc,8E;IAAa,OAAA,OAAQ,O;EAAO,C;EAC5B,+H;IAAA,uB;MAGE,UAEA,M;;QAHA,iBAAS,4BAAwB,qDAAxB,EAAwC,IAAxC,CAAT,C;QADJ,OAEI,gF;;QACF,wC;UAHF,OAII,4EAAiB,SAAjB,Q;;UAJJ,e;;IAMJ,C;G;EACO,6G;IAAA,4B;MAAe,Q;MAAA,+EAAiB,SAAjB,Q;IAA4B,C;G;2EAf1D,oB;IACI,cAAc,a;IACd,OAAQ,QAAO,UAAP,EAAmB,oCAAnB,C;IACR,iB;IACI,kC;IAAgB,U;IAAA,Q;IAAA,Y;IAAA,kB;IAAA,Q;IAAA,e;IAAA,S;IAAA,Y;IAAA,a;IAAA,a;IAAA,Y;ICgGE,SAAkB,S;IAAyC,OAAgB,S;IAAW,WAAoB,S;IAAW,iBAA0B,S;IAAW,OAAqB,S;IAAW,cAAmC,S;IAAW,QAAuB,S;IAAW,WAA6B,S;IAAW,YAAqB,S;IAAW,YAAsB,S;IAAW,WAAe,S;IAC5Z,QAAQ,E;IACR,EAAE,QAAF,IAAc,M;IACd,EAAE,SAAF,IDnG8C,O;ICoG9C,EAAE,MAAF,IAAY,I;IACZ,EAAE,UAAF,IAAgB,Q;IAChB,EAAE,gBAAF,IAAsB,c;IACtB,EAAE,MAAF,IAAY,I;IACZ,EAAE,aAAF,IAAmB,W;IACnB,EAAE,OAAF,IAAa,K;IACb,EAAE,UAAF,IAAgB,Q;IAChB,EAAE,WAAF,IAAiB,S;IACjB,EAAE,WAAF,IAAiB,S;IACjB,EAAE,QAAF,IAAc,Q;ID9GH,mBC+GJ,CD/GI,CAGF,MAAK,2DAAL,CEa4B,MFZvB,6EEYuB,CFJ5B,OAAM,mEAAN,C;EAET,C;;;;;;;;;;;;;SG/BJ,iB;;K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WAC2B,yB;e1BmFF,aACrB,IADqB,EAErB,OAFqB,EAGrB,OAHqB,EAIrB,OAJqB,EAKrB,OALqB,EAMrB,OANqB,EAOrB,OAPqB,EAQrB,OARqB,EASrB,OATqB,EAUrB,OAVqB,EAWrB,OAXqB,EAYrB,OAZqB,EAarB,OAbqB,EAcrB,OAdqB,EAerB,OAfqB,EAgBrB,OAhBqB,EAiBrB,OAjBqB,EAkBrB,OAlBqB,EAmBrB,IAnBqB,EAoBrB,OApBqB,EAqBrB,IArBqB,EAsBrB,OAtBqB,EAuBrB,IAvBqB,EAwBrB,OAxBqB,EAyBrB,IAzBqB,EA0BrB,OA1BqB,EA2BrB,IA3BqB,EA4BrB,OA5BqB,EA6BrB,IA7BqB,EA8BrB,OA9BqB,EA+BrB,OA/BqB,EAgCrB,OAhCqB,EAiCrB,OAjCqB,EAkCrB,OAlCqB,EAmCrB,IAnCqB,EAoCrB,OApCqB,EAqCrB,OArCqB,EAsCrB,IAtCqB,EAuCrB,OAvCqB,EAwCrB,OAxCqB,EAyCrB,OAzCqB,EA0CrB,OA1CqB,EA2CrB,OA3CqB,EA4CrB,OA5CqB,EA6CrB,OA7CqB,EA8CrB,OA9CqB,EA+CrB,OA/CqB,EAgDrB,OAhDqB,EAiDrB,OAjDqB,EAkDrB,IAlDqB,EAmDrB,OAnDqB,EAoDrB,OApDqB,EAqDrB,OArDqB,EAsDrB,OAtDqB,EAuDrB,OAvDqB,EAwDrB,OAxDqB,EAyDrB,OAzDqB,EA0DrB,OA1DqB,EA2DrB,OA3DqB,EA4DrB,OA5DqB,EA6DrB,OA7DqB,EA8DrB,OA9DqB,EA+DrB,OA/DqB,EAgErB,OAhEqB,EAiErB,OAjEqB,EAkErB,OAlEqB,EAmErB,OAnEqB,EAoErB,OApEqB,EAqErB,OArEqB,EAsErB,OAtEqB,EAuErB,OAvEqB,EAwErB,IAxEqB,EAyErB,OAzEqB,EA0ErB,IA1EqB,EA2ErB,OA3EqB,EA4ErB,IA5EqB,EA6ErB,OA7EqB,EA8ErB,OA9EqB,EA+ErB,OA/EqB,EAgFrB,OAhFqB,EAiFrB,OAjFqB,EAkFrB,IAlFqB,EAmFrB,OAnFqB,EAoFrB,IApFqB,EAqFrB,OArFqB,EAsFrB,IAtFqB,EAuFrB,OAvFqB,EAwFrB,IAxFqB,EAyFrB,OAzFqB,EA0FrB,IA1FqB,EA2FrB,OA3FqB,EA4FrB,IA5FqB,EA6FrB,OA7FqB,EA8FrB,IA9FqB,EA+FrB,OA/FqB,EAgGrB,OAhGqB,EAiGrB,IAjGqB,EAkGrB,OAlGqB,EAmGrB,IAnGqB,EAoGrB,OApGqB,EAqGrB,IArGqB,EAsGrB,OAtGqB,EAuGrB,IAvGqB,EAwGrB,OAxGqB,EAyGrB,IAzGqB,EA0GrB,OA1GqB,EA2GrB,IA3GqB,EA4GrB,OA5GqB,EA6GrB,IA7GqB,EA8GrB,OA9GqB,EA+GrB,IA/GqB,EAgHrB,OAhHqB,EAiHrB,IAjHqB,EAkHrB,OAlHqB,EAmHrB,OAnHqB,EAoHrB,IApHqB,EAqHrB,OArHqB,EAsHrB,UAtHqB,EAuHrB,IAvHqB,EAwHrB,OAxHqB,EAyHrB,IAzHqB,EA0HrB,OA1HqB,EA2HrB,OA3HqB,EA4HrB,IA5HqB,EA6HrB,OA7HqB,EA8HrB,IA9HqB,EA+HrB,OA/HqB,EAgIrB,IAhIqB,EAiIrB,OAjIqB,EAkIrB,IAlIqB,EAmIrB,OAnIqB,EAoIrB,IApIqB,EAqIrB,OArIqB,EAsIrB,IAtIqB,EAuIrB,OAvIqB,EAwIrB,aAxIqB,EAyIrB,OAzIqB,EA0IrB,OA1IqB,EA2IrB,aA3IqB,EA4IrB,OA5IqB,EA6IrB,aA7IqB,EA8IrB,WA9IqB,EA+IrB,IA/IqB,EAgJrB,OAhJqB,EAiJrB,IAjJqB,EAkJrB,OAlJqB,EAmJrB,IAnJqB,EAoJrB,OApJqB,EAqJrB,IArJqB,EAsJrB,OAtJqB,EAuJrB,IAvJqB,EAwJrB,OAxJqB,EAyJrB,IAzJqB,EA0JrB,OA1JqB,EA2JrB,OA3JqB,EA4JrB,OA5JqB,EA6JrB,OA7JqB,E;sBAiKO,aAC5B,4CAD4B,EAE5B,+FAF4B,EAG5B,yFAH4B,EAI5B,yFAJ4B,EAK5B,iEAL4B,EAM5B,mFAN4B,EAO5B,mFAP4B,EAQ5B,mFAR4B,EAS5B,6EAT4B,EAU5B,6EAV4B,EAW5B,mFAX4B,EAY5B,sGAZ4B,EAa5B,iEAb4B,EAc5B,+FAd4B,EAe5B,yFAf4B,EAgB5B,6EAhB4B,EAiB5B,uEAjB4B,EAkB5B,6EAlB4B,EAmB5B,wDAnB4B,EAoB5B,2GApB4B,EAqB5B,wDArB4B,EAsB5B,2GAtB4B,EAuB5B,WAvB4B,EAwB5B,qBAxB4B,EAyB5B,mBAzB4B,EA0B5B,6CA1B4B,EA2B5B,OA3B4B,EA4B5B,iBA5B4B,EA6B5B,SA7B4B,EA8B5B,yBA9B4B,EA+B5B,mBA/B4B,EAgC5B,uBAhC4B,EAiC5B,wBAjC4B,EAkC5B,qBAlC4B,EAmC5B,kDAnC4B,EAoC5B,yFApC4B,EAqC5B,yFArC4B,EAsC5B,SAtC4B,EAuC5B,qBAvC4B,EAwC5B,kBAxC4B,EAyC5B,0BAzC4B,EA0C5B,mBA1C4B,EA2C5B,iBA3C4B,EA4C5B,iBA5C4B,EA6C5B,uBA7C4B,EA8C5B,uBA9C4B,EA+C5B,qBA/C4B,EAgD5B,yBAhD4B,EAiD5B,wBAjD4B,EAkD5B,YAlD4B,EAmD5B,wBAnD4B,EAoD5B,sBApD4B,EAqD5B,oBArD4B,EAsD5B,uBAtD4B,EAuD5B,yBAvD4B,EAwD5B,mBAxD4B,EAyD5B,sCAzD4B,EA0D5B,sBA1D4B,EA2D5B,wBA3D4B,EA4D5B,wBA5D4B,EA6D5B,uBA7D4B,EA8D5B,wBA9D4B,EA+D5B,wBA/D4B,EAgE5B,wBAhE4B,EAiE5B,sBAjE4B,EAkE5B,0BAlE4B,EAmE5B,uBAnE4B,EAoE5B,0BApE4B,EAqE5B,6BArE4B,EAsE5B,sBAtE4B,EAuE5B,wBAvE4B,EAwE5B,OAxE4B,EAyE5B,eAzE4B,EA0E5B,OA1E4B,EA2E5B,eA3E4B,EA4E5B,aA5E4B,EA6E5B,wBA7E4B,EA8E5B,sBA9E4B,EA+E5B,sBA/E4B,EAgF5B,sBAhF4B,EAiF5B,0BAjF4B,EAkF5B,SAlF4B,EAmF5B,mBAnF4B,EAoF5B,gCApF4B,EAqF5B,2DArF4B,EAsF5B,UAtF4B,EAuF5B,qBAvF4B,EAwF5B,QAxF4B,EAyF5B,0BAzF4B,EA0F5B,kBA1F4B,EA2F5B,8BA3F4B,EA4F5B,aA5F4B,EA6F5B,yBA7F4B,EA8F5B,UA9F4B,EA+F5B,qBA/F4B,EAgG5B,mBAhG4B,EAiG5B,gCAjG4B,EAkG5B,iEAlG4B,EAmG5B,oBAnG4B,EAoG5B,mCApG4B,EAqG5B,oBArG4B,EAsG5B,+CAtG4B,EAuG5B,eAvG4B,EAwG5B,yBAxG4B,EAyG5B,eAzG4B,EA0G5B,yBA1G4B,EA2G5B,8DA3G4B,EA4G5B,6HA5G4B,EA6G5B,eA7G4B,EA8G5B,0BA9G4B,EA+G5B,OA/G4B,EAgH5B,eAhH4B,EAiH5B,YAjH4B,EAkH5B,wBAlH4B,EAmH5B,wBAnH4B,EAoH5B,OApH4B,EAqH5B,eArH4B,EAsH5B,uBAtH4B,EAuH5B,QAvH4B,EAwH5B,iBAxH4B,EAyH5B,cAzH4B,EA0H5B,uBA1H4B,EA2H5B,yBA3H4B,EA4H5B,gBA5H4B,EA6H5B,6BA7H4B,EA8H5B,4CA9H4B,EA+H5B,mFA/H4B,EAgI5B,iBAhI4B,EAiI5B,0CAjI4B,EAkI5B,uBAlI4B,EAmI5B,mCAnI4B,EAoI5B,OApI4B,EAqI5B,sBArI4B,EAsI5B,sCAtI4B,EAuI5B,iJAvI4B,EAwI5B,oCAxI4B,EAyI5B,sIAzI4B,EA0I5B,mDA1I4B,EA2I5B,0BA3I4B,EA4I5B,+CA5I4B,EA6I5B,uBA7I4B,EA8I5B,gBA9I4B,EA+I5B,SA/I4B,EAgJ5B,mBAhJ4B,EAiJ5B,oBAjJ4B,EAkJ5B,6EAlJ4B,EAmJ5B,cAnJ4B,EAoJ5B,2BApJ4B,EAqJ5B,8DArJ4B,EAsJ5B,2GAtJ4B,EAuJ5B,sBAvJ4B,EAwJ5B,sCAxJ4B,EAyJ5B,cAzJ4B,EA0J5B,6BA1J4B,EA2J5B,6BA3J4B,EA4J5B,mCA5J4B,EA6J5B,6BA7J4B,E;iBsBhO5B,YAAO,MAAO,UAAU,SAAxB,C;;;;"}